<?php
// $Id: nodequeue.module,v 1.39.2.28.2.37 2008/07/06 16:35:41 ezrag Exp $

// --------------------------------------------------------------------------
// Drupal Hooks

/**
 * Implementation of hook_perm
 */
function nodequeue_perm() {
  return array ('manipulate queues', 'administer nodequeue', 'manipulate all queues');
}

/**
 * Implementation of hook_init().
 *
 * Loads subsidiary includes for other modules.
 */
function nodequeue_init() {
  if (module_exists('actions')) {
    include_once drupal_get_path('module', 'nodequeue') . '/nodequeue.actions.inc';
  }

  if (module_exists('workflow_ng')) {
    if (module_exists('actions')) {
      // Workflow_ng and actions module can't work together becuase of API collision.
      drupal_set_message(t('Nodequeue\'s integration with workflow_ng module couldn\'t intizalize as actions module is enabled. Actions module and workflow_ng can\'t be enabled in the same time.'));
    }
    else {
      include_once drupal_get_path('module', 'nodequeue') . '/nodequeue.workflow_ng.inc';	
    }
  }
  if (module_exists('views')) {
    include_once drupal_get_path('module', 'nodequeue') . '/nodequeue.views.inc';
  }
}

/**
 * Implementation of hook_menu
 */
function nodequeue_menu($may_cache) {
  $items = array();
  global $user;

  $admin_access = user_access('administer nodequeue');
  $access = user_access('manipulate queues');

  if ($may_cache) {
    $manipulate = user_access('manipulate all queues');
    // administrative items
    $items[] = array(
      'path' => 'admin/content/nodequeue',
      'title' => t('Node queue'),
      'access' => $admin_access || $access,
      'callback' => 'nodequeue_view_queues',
      'description' => t('Create and maintain simple node queues.'),
      'type' => MENU_NORMAL_ITEM
    );
    $items[] = array(
      'path' => 'admin/content/nodequeue/list',
      'title' => t('List'),
      'access' => $admin_access || $access,
      'callback' => 'nodequeue_view_queues',
      'weight' => -1,
      'type' => MENU_DEFAULT_LOCAL_TASK
    );
    $items[] = array(
      'path' => 'admin/content/nodequeue/settings',
      'title' => t('Settings'),
      'access' => $admin_access,
      'callback' => 'drupal_get_form',
      'callback arguments' => array('nodequeue_admin_settings'),
      'type' => MENU_LOCAL_TASK
    );
    $items[] = array(
      'path' => 'nodequeue/autocomplete',
      'title' => t('Autocomplete'),
      'access' => $access,
      'callback' => 'nodequeue_autocomplete',
      'type' => MENU_CALLBACK
    );
    $items[] = array(
      'path' => 'nodequeue/ajax/add',
      'title' => t('ajax add'),
      'access' => $access,
      'callback' => 'nodequeue_ajax_add',
      'type' => MENU_CALLBACK
    );
    $info = nodequeue_api_info();
    foreach ($info as $key => $data) {
      $items[] = array(
        'path' => 'admin/content/nodequeue/add/' . $key,
        'title' => t('Add @type', array('@type' => strtolower($data['title']))),
        'access' => $admin_access,
        'callback' => 'drupal_get_form',
        'callback arguments' => array('nodequeue_edit_queue_form', $key),
        'type' => MENU_LOCAL_TASK
      );
    }
  }
  else {
    if ($user && arg(0) == 'node' && is_numeric(arg(1)) && arg(1) > 0 && $access && variable_get('nodequeue_use_tab', 1)) {
      $node = node_load(arg(1));
      // nodequeue tab for a node.
      if ($node && $queues = nodequeue_load_queues_by_type($node->type, 'tab')) {
        $items[] = array(
          'path' => 'node/' . arg(1) . '/nodequeue',
          'title' => variable_get('nodequeue_tab_name', t('Node queue')),
          'access' => $access,
          'callback' => 'nodequeue_node_tab',
          'callback arguments' => array($node, $queues),
          'type' => MENU_LOCAL_TASK,
          'weight' => 5
        );
      }
    }

    // Administrative items for an individual queue.
    if ($access &&
        arg(0) == 'admin' &&
        arg(1) == 'content' &&
        arg(2) == 'nodequeue' &&
        is_numeric(arg(3)) &&
        $queue = nodequeue_load(arg(3))) {

      $access = nodequeue_queue_access($queue);
      drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid,
        'access' => $access,
        'callback' => 'nodequeue_admin_view',
        'callback arguments' => array($queue),
        'type' => MENU_CALLBACK
      );
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid . '/view',
        'title' => t('View'),
        'access' => $access,
        'callback' => 'nodequeue_admin_view',
        'callback arguments' => array($queue),
        'weight' => -10,
        'type' => MENU_DEFAULT_LOCAL_TASK
      );
      // Actual administrative items.
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid . '/edit',
        'title' => t('Edit'),
        'access' => $admin_access,
        'callback' => 'drupal_get_form',
        'callback arguments' => array('nodequeue_edit_queue_form', $queue),
        'type' => MENU_LOCAL_TASK
      );
      $items[] = array(
        'path' => 'admin/content/nodequeue/' . $queue->qid . '/delete',
        'title' => t('Delete'),
        'access' => $admin_access,
        'callback' => 'drupal_get_form',
        'callback arguments' => array('nodequeue_admin_delete', $queue),
        'weight' => 5,
        'type' => MENU_CALLBACK
      );

      $sqid = arg(5);
      if (is_numeric($sqid) && $subqueue = nodequeue_load_subqueue($sqid)) {
        $access = ($access && nodequeue_api_subqueue_access($subqueue, $user, $queue));
        // The following operations require a sqid and a nid.
        $nid = arg(6);
        if (in_array(arg(4), array('add', 'remove-node')) &&
            is_numeric($nid)) {
          $node = node_load($nid);
        }

        if ($node && nodequeue_node_access($node->type)) {
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/add/$sqid/$nid",
            'access' => $access,
            'callback' => 'nodequeue_admin_add_node',
            'callback arguments' => array($queue, $subqueue, $node),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/remove-node/$sqid/$nid",
            'access' => $access,
            'callback' => 'nodequeue_admin_remove_node',
            'callback arguments' => array($queue, $subqueue, $node),
            'type' => MENU_CALLBACK
          );
        }

        if (is_numeric($nid)) {
          // IN this case, $nid is actually $pos but why rename the var?
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/up/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_up',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/down/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_down',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/front/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_front',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/back/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_back',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
          $items[] = array(
            'path' => "admin/content/nodequeue/$queue->qid/remove/$sqid",
            'access' => $access,
            'callback' => 'nodequeue_admin_remove',
            'callback arguments' => array($queue, $subqueue, $nid),
            'type' => MENU_CALLBACK
          );
        }
        $items[] = array(
          'path' => "admin/content/nodequeue/$queue->qid/clear/$sqid",
          'title' => t('Clear'),
          'access' => $access,
          'callback' => 'drupal_get_form',
          'callback arguments' => array('nodequeue_clear_confirm', $queue, $subqueue),
          'type' => MENU_CALLBACK
        );
      }
    }
  }
  return $items;
}
/**
 * Implementation of hook_nodeapi
 */
function nodequeue_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch($op) {
    case 'delete':
      // If a node is being deleted, ensure it's also removed from any queues.
      $result = db_query("SELECT * FROM {nodequeue_nodes} WHERE nid = %d", $node->nid);
      while ($obj = db_fetch_object($result)) {
        // This removes by nid, not position, because if we happen to have a
        // node in a queue twice, the 2nd position would be wrong.
        nodequeue_subqueue_remove_node($obj->sqid, $node->nid);
      }
      break;
  }
}

/**
 * Implementation of hook_link
 */
function nodequeue_link($type, $node = NULL, $teaser = FALSE) {
  if ($type == 'node' &&
      variable_get('nodequeue_links', FALSE) &&
      user_access('manipulate queues')) {
    $queues = nodequeue_load_queues_by_type($node->type, 'links');
    $subqueues = nodequeue_get_subqueues_by_node($queues, $node);
    if (empty($subqueues)) {
      return;
    }

    // resort the subqueues to retain consistent ordering:

    ksort($subqueues);
    // Due to caching, we can accidentally get positions leftover
    // from previous iterations on teaser list pages, so we must
    // remove any existing positions here.
    foreach ($subqueues as $id => $subqueue) {
      unset($subqueues[$id]->position);
    }

    nodequeue_set_subqueue_positions($subqueues, $node->nid);

    foreach ($subqueues as $subqueue) {
      $queue = $queues[$subqueue->qid];
      $query_string = nodequeue_get_query_string($node->nid, TRUE);
      if (!isset($subqueue->position)) {
        $links['nodequeue-ajax-toggle-' . $subqueue->sqid] = array(
          'title' => nodequeue_title_substitute($queue->link, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid",
          'attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => $query_string);
      }
      else if ($queue->link_remove) {
        $links['nodequeue-ajax-toggle-' . $subqueue->sqid] = array(
          'title' => nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid",
          'attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => $query_string);
      }
    }
    drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
    drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');
  }
  return $links;
}

// --------------------------------------------------------------------------
// Nodequeue Admin operations

/**
 * Print the JSON output for our AJAX calls.
 */
function nodequeue_js_output($label, $href, $count = NULL, $sqid = NULL) {
  $return = new stdClass();
  $return->status = 1;
  $return->label = check_plain($label);
  $return->href = $href;
  if (isset($count)) {
    $return->count = $count;
  }
  if (isset($sqid)) {
    $return->sqid = $sqid;
  }

  // let the world know this isn't normal output.
  drupal_set_header('Content-type: text/javascript');
  print drupal_to_js($return);
  exit;
}

/**
 * Page callback to add a node to a queue.
 */
function nodequeue_admin_add_node($queue, $subqueue, $node) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }

  nodequeue_subqueue_add($queue, $subqueue, $node->nid);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Remove from queue'),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid", nodequeue_get_query_string($node->nid, TRUE, array('tab'))),
        nodequeue_subqueue_size_text($queue->size, $queue->size ? min($subqueue->count + 1, $queue->size) : $subqueue->count + 1, FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid", nodequeue_get_query_string($node->nid, TRUE)));
    }
  }

  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Page callback to remove a node from a queue.
 */
function nodequeue_admin_remove_node($queue, $subqueue, $node) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }

  nodequeue_subqueue_remove_node($subqueue->sqid, $node->nid);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Add to queue'),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid", nodequeue_get_query_string($node->nid, TRUE, array('tab'))),
        nodequeue_subqueue_size_text($queue->size, $subqueue->count - 1, FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid", nodequeue_get_query_string($node->nid, TRUE)));
    }
  }

  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Display the queue controls for a node.
 *
 * @param $node
 *   The loaded $node; will be loaded by the hook_menu.
 * @param $queues
 *   The list of queues. Loaded by the menu in order to test access control.
 */
function nodequeue_node_tab($node, $queues) {
  $header = array();
  $header[] = array('data' => t('Title'), 'class' => 'nodequeue-title');
  if (variable_get('nodequeue_tab_display_max', 1)) {
    $header[] = array('data' => t('Max nodes'), 'class' => 'nodequeue-max-nodes');
  }
  $header[] = array('data' => t('In queue'), 'class' => 'nodequeue-in-queue');
  $header[] = array('data' => t('Operation'), 'class' => 'nodequeue-operation');
  $subqueues = nodequeue_get_subqueues_by_node($queues, $node);

  nodequeue_set_subqueue_positions($subqueues, $node->nid);

  $rows = array();
  foreach ($subqueues as $subqueue) {
    $queue = $queues[$subqueue->qid];
    if (!$subqueue->position) {
      $op = l(
        t('Add to queue'),
        "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid",
        array('class' => 'nodequeue-ajax-toggle'),
        drupal_get_destination() .'&tab&'. nodequeue_get_token($node->nid)
      );
    }
    else {
      $op = l(
        t('Remove from queue'),
        "admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid",
        array('class' => 'nodequeue-ajax-toggle'),
        drupal_get_destination() .'&tab&'. nodequeue_get_token($node->nid)
      );
    }
    $row = array();
    $row[] = array(
      'class' => 'nodequeue-title',
      'data' => l(nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue), "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid"),
    );
    if (variable_get('nodequeue_tab_display_max', 1)) {
      $row[] = array('class' => 'nodequeue-max-nodes', 'data' => $queue->size ? $queue->size : t('Infinite'));
    }
    $row[] = array(
      'id' => 'nodequeue-count-' . $subqueue->sqid,
      'class' => 'nodequeue-in-queue',
      'data' => nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE)
    );
    $row[] = array('class' => 'nodequeue-operation', 'data' => $op);
    $rows[] = $row;
  }

  $output .= theme('table', $header, $rows, array('class' => 'nodequeue-table'));
  drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
  drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');

  return $output;
}

/**
 * Display a list of queues and their status for the administrator.
 */
function nodequeue_view_queues() {
  // Fetch all of the queues.
  $queues = nodequeue_load_queues(nodequeue_get_all_qids(25));
  foreach ($queues as $queue) {
    if (!nodequeue_queue_access($queue)) {
      unset($queues[$queue->qid]);
    }
  }
  if (empty($queues)) {
    return t('No node queues exist.');
  }

  $qids = array();
  // For every queue that has exactly 1 subqueue,
  foreach ($queues as $queue) {
    if ($queue->subqueues == 1) {
      $qids[] = $queue->qid;
    }
  }

  $subqueues = nodequeue_load_subqueues_by_queue($qids);
  // Relate all the subqueues we loaded back to our queues.
  foreach ($subqueues as $subqueue) {
    if (nodequeue_api_subqueue_access($subqueue, NULL, $queues[$subqueue->qid]));
      $queues[$subqueue->qid]->subqueue = $subqueue;
    }

  $header = array(t('Title'), t('Max nodes'), t('Subqueues'), t('Operation'));
  $rows = array();
  foreach ($queues as $queue) {
    $sub_text = $queue->subqueues;
    if ($sub_text == 1) {
      $sub_text .= " (" . nodequeue_subqueue_size_text($queue->size, $queue->subqueue->count) . ")";
    }

    $operations = array(l(t('View'), "admin/content/nodequeue/$queue->qid/view"));
    if (user_access('administer nodequeue')) {
      $operations[] = l(t('Edit'), "admin/content/nodequeue/$queue->qid/edit");
      $operations[] = l(t('Delete'), "admin/content/nodequeue/$queue->qid/delete");
    }

    $rows[] = array(
      array('class' => 'nodequeue-title', 'data' => check_plain($queue->title)),
      array('class' => 'nodequeue-max-nodes', 'data' => $queue->size == 0 ? t('Infinite') : $queue->size),
      array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
      array('class' => 'nodequeue-operation', 'data' => implode(' | ', $operations)),
    );
  }

  $output = theme('table', $header, $rows);
  $output .= theme('pager', NULL, 25);

  return  $output;
}

/**
 * Display a list of subqueues for a queue and their sizes
 */
function nodequeue_view_subqueues($queue) {
  // Fetch all of the subqueues.
  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);

  $header = array(t('Title'), t('In queue'), t('Operation'));

  $rows = array();
  foreach ($subqueues as $subqueue) {
    if (nodequeue_api_subqueue_access($subqueue, NULL, $queue)) {
      $sub_text = nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE);
      $rows[] = array(
        array('class' => 'nodequeue-title', 'data' => check_plain($subqueue->title)),
        array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
        array('class' => 'nodequeue-operation', 'data' => l(t('View'), "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid"))
      );
    }
  }

  $output = '<p>' . t('Max nodes in queue: @size', array('@size' => $queue->size ? $queue->size : t("Infinite"))) . '</p>';
  $output .= theme('table', $header, $rows);
  $output .= theme('pager', NULL, 20);

  return  $output;
}

/**
 * Add or edit a queue.
 */
function nodequeue_edit_queue_form($queue) {
  // For adding queues.
  if (is_string($queue)) {
    $queue = new nodequeue_queue($queue);
  }

  $info = nodequeue_api_info();

  $form['description'] = array(
    '#type' => 'fieldset',
    '#title' => $info[$queue->owner]['title'],
    '#description' => $info[$queue->owner]['description'],
  );

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#default_value' => $queue->title,
    '#size' => 50,
    '#maxlength' => 64,
    '#description' => t('Enter the name of the queue'),
  );

  // This is a value; as the default nodequeue implementation has just one
  // queue per nodequeue, this field is totally redundant. Plugins can
  // override this.
  $form['subqueue_title'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueue_title,
  );
  // The placeholder is put here so that modifiers have an easy way to put
  // additional form widgets in a prominent spot but not before the title of
  // the queue.
  $form['placeholder'] = array();

  $form['size'] = array(
    '#type' => 'textfield',
    '#title' => t('Queue size'),
    '#default_value' => $queue->size,
    '#size' => 2,
    '#maxlength' => 2,
    '#description' => t('The maximum number of nodes will appear in the queue. Enter 0 for no limit'),
  );

  $form['reverse'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reverse in admin view'),
    '#default_value' => $queue->reverse,
    '#description' => t('Ordinarily queues are arranged with the front of the queue (where items will be removed) on top and the back (where items will be added) on the bottom. If checked, this will display the queue such that items will be added to the top and removed from the bottom.'),
  );

  $form['link'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "add to queue" text'),
    '#default_value' => $queue->link,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('If you want a link to add a node to a queue in the "links" section (next to "add new comment"), enter the text here. If left blank no link will be given; note that enabling this feature for any queue will cause an extra query to be run every time a node is loaded. "%subqueue" will be replaced with the subqueue title, if applicable.'),
  );

  $form['link_remove'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "remove from queue" text'),
    '#default_value' => $queue->link_remove,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('Enter the text for the corresponding link to remove a node from a queue. This may be blank (in which case no link will appear) but a remove link will only appear if link, above, is set.'),
  );

  $result = db_query("SELECT r.* FROM {role} r LEFT JOIN {permission} p ON p.rid = r.rid WHERE p.perm LIKE '%manipulate queues%' ORDER BY r.name");
  while ($role = db_fetch_object($result)) {
    $roles[$role->rid] = $role->name;
  }

  $form['roles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Roles'),
    '#default_value' => $queue->roles,
    '#options' => $roles,
    '#description' => t('Check each role that can add nodes to the queue. Be sure that roles you want to appear here have "manipulate queues" access in the main access control panel.'),
  );

  foreach (node_get_types() as $type => $info) {
    $nodes[$type] = $info->name;
  }

  $form['types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Types'),
    '#default_value' => $queue->types,
    '#options' => $nodes,
    '#description' => t('Check each node type that can be added to this queue.'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  $form['owner'] = array(
    '#type' => 'value',
    '#value' => $queue->owner,
  );

  $form['show_in_links'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_links,
  );

  $form['show_in_tab'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_tab,
  );

  $form['show_in_ui'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_ui,
  );

  $form['reference'] = array(
    '#type' => 'value',
    '#value' => $queue->reference,
  );

  $form['subqueues'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueues,
  );

  if (isset($queue->qid)) {
    $form[] = array(
      '#type' => 'submit',
      '#value' => t('Delete'),
    );
    $form['qid'] = array(
      '#type' => 'value',
      '#value' => $queue->qid,
    );
    $form['count'] = array(
      '#type' => 'value',
      '#value' => $queue->count,
    );
  }

  nodequeue_api_queue_form($queue, $form);

  return $form;
}

/**
 * Submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_validate($formid, $form_values, &$form) {
  if ($form_values['op'] == t('Delete')) {
    return;
  }
  $queue = (object) $form_values;
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  nodequeue_api_queue_form_validate($queue, $form_values, $form);
}

/**
 * Submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_submit($formid, $form) {
  if ($form['op'] == t('Delete')) {
    return "admin/content/nodequeue/$form[qid]/delete";
  }

  $queue = (object) $form;
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  // Modify show_in_links based on whether or not links are available.
  $queue->show_in_links = !empty($queue->link) && !empty($queue->link_remove);

  nodequeue_api_queue_form_submit($queue, $form);

  $qid = nodequeue_save($queue);

  nodequeue_api_queue_form_submit_finish($queue, $form);

  nodequeue_check_subqueue_sizes($queue);

  if ($queue->new) {
    drupal_set_message(t('The queue has been created.'));
  }
  else {
    drupal_set_message(t('The queue has been updated.'));
  }
  return 'admin/content/nodequeue';
}

/**
 * Confirm form to delete a queue
 */
function nodequeue_admin_delete($queue) {
  $form['qid'] = array('#type' => 'value', '#value' => $queue->qid);
  return confirm_form($form,
    t('Are you sure you want to delete "%title"?', array('%title' => $queue->title)),
    $_GET['destination'] ? $_GET['destination'] : 'admin/content/nodequeue',
    t('This action cannot be undone.'),
    t('Delete'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue delete
 */
function nodequeue_admin_delete_submit($formid, $form) {
  if ($form['confirm']) {
    nodequeue_delete($form['qid']);
    drupal_set_message("The queue has been deleted.");
  }
  return 'admin/content/nodequeue';
}

/**
 * Page callback to view a queue.
 */
function nodequeue_admin_view($queue, $sqid = NULL) {
  $qid = $queue->qid;

  // If the queue has just one subqueue, it gets special treatment.
  if (!$sqid) {
    if ($queue->subqueues == 1) {
      $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
      $subqueue = array_shift($subqueues);
    }
    else {
      // display subqueue list page.
      return nodequeue_view_subqueues($queue);
    }
    $sqid = $queue->current;
  }
  else if ($sqid) {
    // Adjust properties of the page so our subqueue is in the right
    // visual place.
    $subqueue = nodequeue_load_subqueue($sqid);
    if (!nodequeue_api_subqueue_access($subqueue, NULL, $queue)) {
      return drupal_not_found();
    }
    drupal_set_title(t("Subqueue '@title'",
      array('@title' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))));
    $breadcrumb = drupal_get_breadcrumb();
    $breadcrumb[] = l($queue->title, "admin/content/nodequeue/$queue->qid");
    drupal_set_breadcrumb($breadcrumb);
  }

  return nodequeue_arrange_subqueue($queue, $subqueue);
}

function nodequeue_arrange_subqueue_entry($queue, $subqueue, $node) {
  $qid = $queue->qid;
  $sqid = $subqueue->sqid;
  $query_string = nodequeue_get_query_string($node->position, TRUE);

  $buttons = l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-up.png', t('Move up')),
    "admin/content/nodequeue/$qid/up/$sqid/$node->position",
    array(
      'title' => t('Move up'),
      'class' => 'nodequeue-move-up',
    ), $query_string, NULL, FALSE, TRUE);
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-down.png', t('Move down')),
    "admin/content/nodequeue/$qid/down/$sqid/$node->position",
    array(
      'title' => t('Move down'),
      'class' => 'nodequeue-move-down',
    ), $query_string, NULL, FALSE, TRUE);
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-top.png', t('Move to front')),
    "admin/content/nodequeue/$qid/front/$sqid/$node->position",
    array(
      'title' => t('Move to front'),
      'class' => 'nodequeue-move-front',
    ), $query_string, NULL, FALSE, TRUE);
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-bottom.png', t('Move to back')),
    "admin/content/nodequeue/$qid/back/$sqid/$node->position",
    array(
      'title' => t('Move to back'),
      'class' => 'nodequeue-move-back',
    ), $query_string, NULL, FALSE, TRUE);
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/delete.png', t('Remove from queue')),
    "admin/content/nodequeue/$qid/remove/$sqid/$node->position",
    array(
      'title' => t('Remove from queue'),
      'class' => 'nodequeue-remove',
    ), $query_string, NULL, FALSE, TRUE);

  $output = '<tr id="nodequeue-row-' . $node->position . '" class="nodequeue-row ' . ($node->position % 2 ? 'odd' : 'even') . '">';
  $output .= '<td>' . l($node->title, "node/$node->nid") . '</td>';
  $output .= '<td>' . theme('username', $node) . '</td>';
  $output .= '<td>' . format_date($node->created) . '</td>';
  $output .= '<td>' . $buttons . '</td>';
  $output .= '</tr>';
  return $output;
}

/**
 * View the contents of a subqueue, with links to re-order the queue.
 */
function nodequeue_arrange_subqueue($queue, $subqueue) {
  $qid = $queue->qid;
  $sqid = $subqueue->sqid;
  $output = '';

  $order = $queue->reverse ? 'DESC' : 'ASC';
  $result = db_query("SELECT DISTINCT(n.nid), n.title, n.uid, u.name, n.created, nq.position FROM {node} n LEFT JOIN {users} u on n.uid = u.uid LEFT JOIN {nodequeue_nodes} nq ON nq.nid = n.nid WHERE nq.sqid = %d ORDER BY nq.position $order", $sqid);

  $body = '';

  $nids = array();
  while ($node = db_fetch_object($result)) {
    $nids[$node->position] = $node->nid;
    $body .= nodequeue_arrange_subqueue_entry($queue, $subqueue, $node);
  }

  $output = '<p>' . t('Max nodes in queue: @size', array('@size' => $queue->size ? $queue->size : t("Infinite"))) . '</p>';

  $output .= '<p class="nodequeue-hide-if-not-js nodequeue-warning">';
  $output .= t('Changes made to the queue order and queue removals will not be active until you click Save, below. If you add more nodes than the queue can hold, they will be removed from the @end when you save!', array('@end' => $queue->reverse ? t('bottom') : t('top')));
  $output .= '</p>';

  $output .= '<table id="nodequeue-table">';
  $output .= '<thead>';
  $output .= '<tr>';
  $output .= '<th class="nodequeue-node">' . t('Node') . '</th>';
  $output .= '<th class="nodequeue-author">' . t('Author') . '</th>';
  $output .= '<th class="nodequeue-date">' . t('Date') . '</th>';
  $output .= '<th class="nodequeue-operation">' . t('Operation') . '</th>';
  $output .= '</thead>';
  $output .= '<tbody>' . $body . '</tbody>';
  $output .= '</table>';

  $output .= drupal_get_form('nodequeue_arrange_subqueue_form', $queue, $sqid, $nids);
  drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');

  return $output;
}

/**
 * Form used for arranging a queue
 */
function nodequeue_arrange_subqueue_form($queue, $sqid, $nids) {
  $form['qid'] = array(
    '#type' => 'value',
    '#value' => $queue->qid,
  );

  $form['sqid'] = array(
    '#type' => 'hidden',
    '#value' => $sqid,
  );

  $form['order'] = array(
    '#type' => 'hidden',
    '#id' => 'nodequeue-order',
    '#default_value' => implode(',', array_keys($nids)),
  );

  $form['add'] = array(
    '#type' => 'textfield',
    '#title' => t('Select title to add'),
    '#autocomplete_path' => "nodequeue/autocomplete/$sqid",
    '#default_value' => '',
  );

  // For use by the validate handler
  $form['nid'] = array(
    '#type' => 'value',
    '#value' => 0,
  );

  $form['add_submit'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-add'),
    '#value' => t('Add'),
  );

  $form['save'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-hide-if-not-js-hide nodequeue-save'),
    '#value' => t('Save'),
  );

  $form['clear'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-clear'),
    '#value' => t('Clear'),
  );

  $form['reverse_click'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-reverse'),
    '#value' => t('Reverse'),
  );

  $form['shuffle'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-shuffle'),
    '#value' => t('Shuffle'),
  );

  // Store the original order.
  $form['nids'] = array(
    '#type' => 'value',
    '#value' => $nids,
  );

  $form['added_nids'] = array(
    '#type' => 'hidden',
    '#default_value' => '',
  );

  $settings = array(
    'nodequeue-table' => array(
      // The gadget that stores our the order of items.
      'order' => 'input#nodequeue-order',
      // The buttons that do stuff.
      'up' => 'a.nodequeue-move-up',
      'down' => 'a.nodequeue-move-down',
      'top' => 'a.nodequeue-move-front',
      'bottom' => 'a.nodequeue-move-back',
      'remove' => 'a.nodequeue-remove',

      // The button that adds an item
      'add' => 'input.nodequeue-add',
      // The buttom to clear the queue
      'clear_list' => 'input.nodequeue-clear',
      // Path for js to shuffle the queue
      'shuffle' => 'input.nodequeue-shuffle',
      // Path for js to reverse the queue
      'reverse' => 'input.nodequeue-reverse',
      // Path for ajax on adding an item
      'path' => url('nodequeue/ajax/add', NULL, NULL, TRUE),
      // Which items to post when adding
      'post' => array('#edit-sqid', '#edit-add'),
      // Where to get the id of an item
      'tr' => 'nodequeue-row-',
      'row_class' => 'tr.nodequeue-row',
      // Where to put the extra (we're storing a nid)
      'extra' => '#edit-added-nids',
      // What item to focus on ready
      'focus' => '#edit-add',
      // What item(s) to clear after add
      'clear' => array('#edit-add'),
      // What hidden class to show as soon as anything has changed that needs saving.
      'hidden' => '.nodequeue-js-hide',
      // Do we add to the top or the bottom?
      'add_location' => $queue->reverse ? 'top' : 'bottom',
    ),
  );
  drupal_add_js(array('nodequeue' => $settings), 'setting');
  drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');

  return $form;
}

function theme_nodequeue_arrange_subqueue_form($form) {
  $header = array(
    check_plain($form['add']['#title']),
    '',
  );

  unset($form['add']['#title']);
  $rows = array(
    drupal_render($form['add']),
    array('data' => drupal_render($form['add_submit']), 'width' => '80%'),
  );

  $output = theme('table', $header, array($rows));
  $output .= drupal_render($form);
  return $output;
}

/**
 * Validate handler for nodequeue_arrange_subqueue_form
 */
function nodequeue_arrange_subqueue_form_validate($form_id, $form_values, $form) {
  if ($form_values['op'] == t('Add')) {
    $queue = nodequeue_load($form_values['qid']);
    $subqueue = nodequeue_load($form_values['sqid']);
    $nodes = nodequeue_api_autocomplete($queue, $subqueue, $form_values['add']);
    if (empty($nodes) || !is_array($nodes)) {
      form_error($form['add'], t('Invalid node'));
      return;
    }
    if (count($nodes) > 1) {
      form_error($form['add'], t('That matches too many nodes'));
      return;
    }
    $keys = array_keys($nodes);
    $nid = array_pop($keys);
    form_set_value($form['nid'], $nid);
    return;
  }

  if ($form_values['op'] == t('Save')) {
    $nids = $form_values['nids'];

    // We can't use array_merge because it'll reset our keys and we can't
    // use + because it will overwrite.
    if ($form_values['added_nids']) {
      foreach (explode(',', $form_values['added_nids']) as $nid) {
        if (empty($nids)) {
          $nids[1] = $nid;
        }
        else {
          $nids[max(array_keys($nids)) + 1] = $nid;
        }
      }
    }
    form_set_value($form['nids'], $nids);
  }
}

/**
 * Submit function for nodequeue_arrange_subqueue_form
 */
function nodequeue_arrange_subqueue_form_submit($form_id, $form_values) {
  // Add a node to the queue if that's the intention.
  if ($form_values['op'] == t('Clear')) {
    return 'admin/content/nodequeue/' . $form_values['qid'] . '/clear/' . $form_values['sqid'];
  }

  $queue = nodequeue_load($form_values['qid']);
  $subqueue = nodequeue_load_subqueue($form_values['sqid']);

  if ($form_values['op'] == t('Add')) {
    nodequeue_subqueue_add($queue, $subqueue, $form_values['nid']);
    return;
  }

  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d", $form_values['sqid']);
  if ($form_values['order']) {
    $now = time();
    $sql = '';
    $args = array();
    $nids = $form_values['nids'];
    $subqueue->count = 0;
    $order = explode(',', $form_values['order']);
    if ($queue->reverse xor $form_values['op'] == t('Reverse')) {
      $order = array_reverse($order);
    }

    foreach ($order as $new_pos => $old_pos) {
      if ($sql) {
        $sql .= ', ';
      }
      $sql .= ' (%d, %d, %d, %d, %d)';
      $args[] = $form_values['sqid'];
      $args[] = $form_values['qid'];
      $args[] = $nids[$old_pos];

      // $new_pos starts from 0 but we start from 1.
      $args[] = $new_pos + 1;
      $args[] = $now;
      $subqueue->count++;
    }
    $sql = "INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES $sql";
    db_query($sql, $args);
    if ($queue->size) {
        // 0 means infinity so never do this if false
        nodequeue_check_subqueue_size($queue, $subqueue);
    }
    if ($form_values['op'] == t('Shuffle')) {
      nodequeue_subqueue_shuffle($subqueue);
    }
  }
  drupal_set_message(t('The queue has been updated'));
}

/**
 * Page callback to move an item up in a queue. This will be used only if
 * javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_up($queue, $subqueue, $pos) {
  if (!nodequeue_check_token($pos)) {
    return drupal_goto();
  }

  // This function is safe if $pos is out of bounds.
  if (!$queue->reverse) {
    nodequeue_queue_up($subqueue, $pos);
  } else {
    nodequeue_queue_down($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to move an item down in a queue. This will be used only if
 * javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_down($queue, $subqueue, $pos) {
  if (!nodequeue_check_token($pos)) {
    return drupal_goto();
  }

  // This function is safe if $pos is out of bounds.
  if ($queue->reverse) {
    nodequeue_queue_up($subqueue, $pos);
  } else {
    nodequeue_queue_down($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to move an item to the front of a queue. This will be used
 * only if javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_front($queue, $subqueue, $pos) {
  if (!nodequeue_check_token($pos)) {
    return drupal_goto();
  }

  // This function is safe if $pos is out of bounds.
  if (!$queue->reverse) {
    nodequeue_queue_front($subqueue, $pos);
  } else {
    nodequeue_queue_back($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to move an item to the back of a queue. This will be used
 * only if javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_back($queue, $subqueue, $pos) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }

  // This function is safe if $pos is out of bounds.
  if ($queue->reverse) {
    nodequeue_queue_front($subqueue, $pos);
  } else {
    nodequeue_queue_back($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to remove an item from a queue. This will be used only
 * if javascript is disabled in the client, and is a fallback technique.
 * This differs from nodequeue_admin_remove_node in that it removes a
 * specific position, which is necessary in case a node is in a queue
 * multiple times.
 */
function nodequeue_admin_remove($queue, $subqueue, $pos) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }

  nodequeue_subqueue_remove($subqueue->sqid, $pos);

  drupal_goto();
}

/**
 * Confirm form to clear a queue.
 */
function nodequeue_clear_confirm($queue, $subqueue) {
  $form['sqid'] = array('#type' => 'value', '#value' => $subqueue->sqid);
  $form['qid'] = array('#type' => 'value', '#value' => $queue->qid);
  return confirm_form($form,
    t('Clearing queue "%s" is irreversible. You sure?', array('%s' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))),
    $_GET['destination'] ? $_GET['destination'] : "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid",
    t('This action cannot be undone.'),
    t('Clear'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue clear confirm
 */
function nodequeue_clear_confirm_submit($formid, $form) {
  if ($form['confirm']) {
    nodequeue_queue_clear($form['sqid']);
    return "admin/content/nodequeue/$form[qid]/view/$form[sqid]";
  }
}

/**
 * Page callback for autocomplete.
 */
function nodequeue_autocomplete($sqid = NULL, $string = NULL) {
  $output = _nodequeue_autocomplete($sqid, $string);

  // let the world know this isn't normal output.
  drupal_set_header('Content-type: text/javascript');
  print drupal_to_js(drupal_map_assoc($output));
  exit;
}

function _nodequeue_autocomplete($sqid, $string) {
  $output = array();

  if (!$sqid || !is_numeric($sqid) || !$string) {
    return $output;
  }

  $subqueue = nodequeue_load_subqueue($sqid);
  if (!$subqueue) {
    return $output;
  }

  $queue = nodequeue_load($subqueue->qid);
  if (!$queue) {
    return $output;
  }

  $nodes = nodequeue_api_autocomplete($queue, $subqueue, $string);
  return $nodes;
}

/**
 * Page callback to ajaxily add a node.
 */
function nodequeue_ajax_add() {
  $sqid = $_POST['sqid'];
  $position = $_POST['position'];
  $string = $_POST['add'];
  $output = _nodequeue_ajax_add($sqid, $position, $string);
  // let the world know this isn't normal output.
  drupal_set_header('Content-type: text/javascript');
  print drupal_to_js($output);
  exit;
}

function _nodequeue_ajax_add($sqid, $position, $string) {
  if (!$string) {
    return array('error' => t('Invalid input'));
  }

  if (!$sqid || !is_numeric($sqid)) {
    return array('error' => t('Invalid sqid'));
  }

  $subqueue = nodequeue_load_subqueue($sqid);
  if (!$subqueue) {
    return array('error' => t('Invalid sqid'));
  }

  if (!nodequeue_api_subqueue_access($subqueue)) {
    return array('error' => t('Access denied'));
  }

  $queue = nodequeue_load($subqueue->qid);
  if (!$queue) {
    return array('error' => t('Invalid sqid'));
  }

  $nodes = nodequeue_api_autocomplete($queue, $subqueue, $string);
  if (empty($nodes) || !is_array($nodes)) {
    return array('error' => t('Invalid node'));
  }

  if (count($nodes) > 1) {
    return array('error' => t('That matches too many nodes'));
  }

  $keys = array_keys($nodes);
  $node = node_load(array_pop($keys));

  if (!node_access('view', $node)) {
    return array('error' => t('Invalid node'));
  }

  $node->position = $position;
  return array(
    'status' => 1,
    'extra' => $node->nid,
    'max' => $queue->size,
    'data' => nodequeue_arrange_subqueue_entry($queue, $subqueue, $node),
  );
}

// --------------------------------------------------------------------------
// Nodequeue manipulation API.

/**
 * @defgroup nodequeue_api
 * @{
 * Access to the internals of nodequeues are handled primarily through these
 * API functions. They allow easy loading of queues for manipulation.
 */

/**
 * The nodequeue queue class; the constructor makes it so we don't have to
 * always check to see if our variables are empty or not.
 */
class nodequeue_queue {
  var $title = '';
  var $size = 0;
  var $link = '';
  var $remove_link = '';
  var $roles = array();
  var $types = array();
  var $show_in_links = TRUE;
  var $show_in_tab = TRUE;
  var $show_in_ui = TRUE;
  var $reference = 0;

  var $subqueue = array();
  function nodequeue_queue($type) {
    $this->owner = $type;
  }
}

/**
 * Return TRUE If the specified account has access to manipulate this queue.
 */
function nodequeue_queue_access($queue, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  // Automatically true if all queues.
  if (user_access('manipulate all queues')) {
    return TRUE;
  }

  // Automatically false if they can't manipulate queues at all.
  if (!user_access('manipulate queues') || empty($queue->roles)) {
    return FALSE;
  }
  
  // Return false if the queue's owner rejects access to the queue.
  if (!nodequeue_api_queue_access($queue, $account)) {
    return FALSE;
  }

  $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);
  return (bool) array_intersect($roles, $queue->roles);
}

/**
 * Fetch a list of available queues for a given location. These queues
 * will be fully loaded and ready to go.
 */
function nodequeue_load_queues_by_type($type, $location = NULL, $account = NULL) {
  $qids = nodequeue_get_qids($type, $account);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }
  return nodequeue_load_queues(array_keys($qids));
}

/**
 * Return TRUE if $user can queue(s) for this node.
 *
 * @param $type
 *   The node type.
 * @param $location
 *   Optional argument. May be one of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_node_access($type, $location = NULL, $account = NULL) {
  $qids = nodequeue_get_qids($type, $account);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }

  return !empty($qids);
}

/**
 * Filter a list of qids returned by nodequeue_get_qids to a location.
 *
 * @param $qids
 *   An array of $qids from @see nodequeue_get_qids()
 * @param $location
 *   One of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_filter_qids(&$qids, $location) {
  $var = "show_in_$location";
  foreach ($qids as $qid => $info) {
    if (empty($info->$var)) {
      unset($qids[$qid]);
    }
  }
}

/**
 * Get an array of qids applicable to this node type.
 *
 * @param $type
 *   The node type.
 * @param $account
 *   The account to test against. Defaults to the currently logged in user.
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *   => true/false, 'show_in_links' => true/false }
 */
function nodequeue_get_qids($type, $account = NULL) {
  if (!isset($account)) {
    global $user;
    $account = $user;
  }

  static $cache = array();
  if (!isset($cache[$type])) {
    $roles_join = $roles_where = '';
    $roles = array();

    // superuser always has access.
    if (!user_access('manipulate all queues', $account)) {
      $roles_join = "INNER JOIN {nodequeue_roles} nr ON nr.qid = nq.qid ";
      $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);
      $role_args = array_fill(0, count($roles), '%d');

      $roles_where .= "AND nr.rid IN (". implode(',', $role_args) .")";
    }

    $sql = 'SELECT nq.qid, nq.show_in_tab, nq.show_in_links, show_in_ui ' .
      'FROM {nodequeue_queue} nq ' .
      'INNER JOIN {nodequeue_types} nt ON nt.qid = nq.qid ' . $roles_join .
      "WHERE nt.type = '%s' " . $roles_where;
    $result = db_query($sql, array_merge(array($type), $roles));

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid;
    }
    $cache[$type] = $qids;
  }
  return $cache[$type];
}

/**
 * Get an array all qids using the pager query. This administrative list
 * does no permission checking, so should only be available to users who
 * have passed the 'administer queues' check.
 *
 * @param $page_size
 *   The page size to use. If 0 will be all queues.
 * @param $pager_element
 *   In the rare event this should use another pager element, set this..
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *   => true/false, 'show_in_links' => true/false }
 */
function nodequeue_get_all_qids($page_size = 25, $pager_element = 0) {
  static $cache = NULL;
  if (!isset($cache)) {
    $sql = 'SELECT nq.qid ' .
           'FROM {nodequeue_queue} nq ' .
           'WHERE nq.show_in_ui = 1 ';
    $count_sql = 'SELECT COUNT(q.qid) FROM {nodequeue_queue} q WHERE q.show_in_ui = 1 ';
    if ($page_size) {
      $result = pager_query($sql, $page_size, $pager_element, $count_sql);
    }
    else {
      $result = db_query($sql, $count_sql);
    }

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid->qid;
    }
    $cache = $qids;
  }
  return $cache;
}

/**
 * Load an array of $qids.
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $qids
 *   An array of queue IDs to load.
 */
function nodequeue_load_queues($qids) {
  static $cache = array();
  $to_load = $queues = array();

  foreach ($qids as $qid) {
    if (!isset($cache[$qid])) {
      $to_load[] = $qid;
    }
  }

  if (!empty($to_load)) {
    $load_text = implode(', ', $to_load);
    $result = db_query("SELECT q.*, COUNT(s.sqid) AS subqueues FROM {nodequeue_queue} q LEFT JOIN {nodequeue_subqueue} s ON q.qid = s.qid WHERE q.qid IN (%s) GROUP BY q.qid", $load_text);
    while ($queue = db_fetch_object($result)) {
      $cache[$queue->qid] = $queue;
    }

    $result = db_query("SELECT * FROM {nodequeue_roles} WHERE qid IN (%s)", $load_text);
    while ($obj = db_fetch_object($result)) {
      $cache[$obj->qid]->roles[] = $obj->rid;
    }

    $result = db_query("SELECT * FROM {nodequeue_types} WHERE qid IN (%s)", $load_text);
    while ($obj = db_fetch_object($result)) {
      $cache[$obj->qid]->types[] = $obj->type;
    }
  }

  foreach ($qids as $qid) {
    if (isset($cache[$qid])) {
      $queues[$qid] = $cache[$qid];
    }
  }
  return $queues;
}

/**
 * Load a nodequeue.
 *
 * @param $qid
 *   The qid of the queue to load.
 */
function nodequeue_load($qid) {
  $queues = nodequeue_load_queues(array($qid));
  return array_shift($queues);
}

/**
 * Load a list of subqueues
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $sqids
 *   An array of subqueue IDs to load.
 */
function nodequeue_load_subqueues($sqids) {
  static $cache = array();
  $to_load = array();

  foreach ($sqids as $sqid) {
    if (!isset($cache[$sqid])) {
      $to_load[] = $sqid;
    }
  }

  if (!empty($to_load)) {
    $load_text = implode(', ', $to_load);

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.sqid IN (%s) GROUP BY s.sqid", $load_text);
    while ($obj = db_fetch_object($result)) {
      // Sometimes we want to get to subqueues by reference, sometimes by sqid.
      // sqid is always unique, but reference is sometimes more readily available.
      $cache[$obj->sqid] = $obj;
    }
  }

  foreach ($sqids as $sqid) {
    if (isset($cache[$sqid])) {
      $subqueues[$sqid] = $cache[$sqid];
    }
  }
  return $subqueues;
}

/**
 * Load a single subqueue.
 *
 * @param $sqid
 *   The subqueue ID to load.
 */
function nodequeue_load_subqueue($sqid) {
  $subqueues = nodequeue_load_subqueues(array($sqid));
  if ($subqueues) {
    return array_shift($subqueues);
  }

}

/**
 * Load the entire set of subqueues for a queue.
 *
 * This will load the entire set of subqueues for a given queue (and can
 * respect the pager, if desired). It does NOT cache the subqueues like
 * nodequeue_load_subqueues does, so beware of this mixed caching.
 *
 * @param $qids
 *   A $qid or array of $qids
 * @param $page_size
 *   If non-zero, use the pager_query and limit the page-size to the parameter.
 */
function nodequeue_load_subqueues_by_queue($qids, $page_size = 0) {
  if (is_numeric($qids)) {
    $qids = array($qids);
  }

  if (empty($qids)) {
    return array();
  }

  $query = "SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.qid IN (" . implode(', ', array_fill(0, count($qids), '%d')) . ") GROUP BY s.sqid";
  if ($page_size) {
    $result = pager_query($query, $page_size, 0, $qids);
  }
  else {
    $result = db_query($query, $qids);
  }

  $subqueues = array();

  while ($subqueue = db_fetch_object($result)) {
    $subqueues[$subqueue->sqid] = $subqueue;
  }

  return $subqueues;
}

/**
 * Load a set of subqueues by reference.
 *
 * This can be used to load a set of subqueues by reference; it will primarily
 * be used by plugins that are managing subqueues.
 *
 * @param $references
 *   A keyed array of references to load. The key is the $qid and each value
 *   is another array of references.
 */
function nodequeue_load_subqueues_by_reference($references) {
  static $cache = array();
  $subqueues = array();

  // build strings for the query based upon the qids and references.
  $keys = $values = array();
  foreach ($references as $qid => $qid_references) {
    $keys[$qid] = array();
    $qid_values = array();
    foreach ($qid_references as $reference) {
      // If we already have this qid/reference combo cached, don't add it to
      // our little list.
      if (isset($cache[$qid][$reference])) {
        $subqueues[$cache[$qid][$reference]->sqid] = $cache[$qid][$reference];
      }
      else {
        $keys[$qid][] = "'%s'";
        $qid_values[] = $reference;
      }
    }
    if (!empty($keys[$qid])) {
      $values = array_merge($values, array($qid), $qid_values);
    }
    else {
      unset($keys[$qid]);
    }
  }

  if (!empty($keys)) {
    $where = '';
    foreach ($keys as $key_list) {
      if ($where) {
        $where .= ' OR ';
      }
      $where .= 's.qid = %d AND s.reference IN (' . implode(', ', $key_list) . ')';
    }

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE $where GROUP BY s.sqid", $values);

    while ($subqueue = db_fetch_object($result)) {
      $cache[$subqueue->qid][$subqueue->reference] = $subqueues[$subqueue->sqid] = $subqueue;
    }
  }

  return $subqueues;
}

/**
 * Save a nodequeue. This does not save subqueues; those must be added separately.
 */
function nodequeue_save(&$queue) {
  if (!isset($queue->qid)) {
    $queue->qid = db_next_id("{nodequeue_queue}_qid");
    db_query("INSERT INTO {nodequeue_queue} (qid, title, subqueue_title, size, link, link_remove, owner, show_in_links, show_in_tab, show_in_ui, reverse, reference) VALUES (%d, '%s', '%s', %d, '%s', '%s', '%s', %d, %d, %d, %d, '%s')", $queue->qid, $queue->title, $queue->subqueue_title, $queue->size, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->reverse, $queue->reference);
    if (function_exists('views_invalidate_cache')) {
      views_invalidate_cache();
    }
  }
  else {
    db_query("UPDATE {nodequeue_queue} set size = %d, title = '%s', subqueue_title = '%s', link = '%s', link_remove = '%s', owner = '%s', show_in_links = %d, show_in_tab = %d, show_in_ui = %d, reverse = %d, reference = '%s' WHERE qid = %d", $queue->size, $queue->title, $queue->subqueue_title, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->reverse, $queue->reference, $queue->qid);
    db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $queue->qid);
    db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $queue->qid);
    if ($nodes) {
      db_query("DELETE FROM {nodequeue_nodes} WHERE qid = %d", $queue->qid);
    }
  }

  if (is_array($queue->roles)) {
    foreach($queue->roles as $rid)
      db_query("INSERT INTO {nodequeue_roles} (qid, rid) VALUES (%d, %d)", $queue->qid, $rid);
  }

  if (is_array($queue->types)) {
    foreach($queue->types as $type)
    db_query("INSERT INTO {nodequeue_types} (qid, type) VALUES (%d, '%s')", $queue->qid, $type);
  }

  // set our global that tells us whether or not we need to activate hook_link
  if (db_result(db_query("SELECT COUNT(*) FROM {nodequeue_queue} WHERE link != ''"))) {
    variable_set('nodequeue_links', TRUE);
  }
  else {
    variable_set('nodequeue_links', FALSE);
  }

  if (isset($queue->add_subqueue) && is_array($queue->add_subqueue)) {
    foreach ($queue->add_subqueue as $reference => $title) {
      // If reference is unset it should be set to the qid; this is generally
      // used for a single subqueue; setting the reference to the qid makes
      // it easy to find that one subqueue.
      if ($reference == 0) {
        $reference = $queue->qid;
      }
      nodequeue_add_subqueue($queue, $title, $reference);
    }
  }
  return $queue->qid;
}

/**
 * Delete a nodequeue.
 */
function nodequeue_delete($qid) {
  db_query("DELETE FROM {nodequeue_queue} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_nodes} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_subqueue} WHERE qid = %d", $qid);
}

/**
 * Add a new subqueue to a queue.
 *
 * @param $qid
 *   The queue id. This should not be the full queue object.
 * @param $reference
 *   A reference that uniquely identifies this subqueue. If NULL it will
 *   be assigned to the sqid.
 */
function nodequeue_add_subqueue(&$queue, $title, $reference = NULL) {
  $sqid = db_next_id('{nodequeue_subqueue}_sqid');
  if (empty($reference)) {
    $reference = $sqid;
  }

  $subqueue = new stdClass();
  $subqueue->sqid = $sqid;
  $subqueue->reference = $reference;
  $subqueue->qid = $queue->qid;
  $subqueue->title = $title;

  db_query("INSERT INTO {nodequeue_subqueue} (qid, sqid, reference, title) VALUES (%d, %d, '%s', '%s')", $queue->qid, $sqid, $reference, $title);

  return $subqueue;
}

/**
 * Change the title of a subqueue.
 *
 * Note that only the title of a subqueue is changeable; it can change to
 * reflect updates in taxonomy term names, for example.
 */
function nodequeue_subqueue_update_title($sqid, $title) {
  db_query("UPDATE {nodequeue_subqueue} SET title = '%s' WHERE sqid = %d", $title, $sqid);
}

/**
 * Remove a subqueue.
 */
function nodequeue_remove_subqueue($sqid) {
  nodequeue_queue_clear($sqid);
  db_query("DELETE FROM {nodequeue_subqueue} WHERE sqid = %d", $sqid);
}

// --------------------------------------------------------------------------
// Queue position control

/**
 * Add a node to a queue.
 *
 * @param $queue
 *   The parent queue of the subqueue. This is required so that we can
 *   pop nodes out if the queue breaks size limits.
 * @param $sqid
 *   The subqueue ID to add the node to.
 * @param $nid
 *   The node ID
 */
function nodequeue_subqueue_add($queue, $subqueue, $nid) {
  // If adding this would make the queue too big, pop the front node
  // (or nodes) out.

  if ($queue->size) {
    // 0 means infinity so never do this if false
    nodequeue_check_subqueue_size($queue, $subqueue, $queue->size - 1);
  }

  db_query("INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES (%d, %d, %d, %d, %d)", $subqueue->sqid, $queue->qid, $nid, $subqueue->count + 1, time());
}

/**
 * Remove a node from the queue. If a node is in the queue more than once,
 * only the first (closest to 0 position, or the front of the queue) will
 * be removed.
 *
 * @param $sqid
 *   The subqueue to remove nodes from.
 * @param $nid
 *   The node to remove.
 */
function nodequeue_subqueue_remove_node($sqid, $nid) {
  if ($pos = nodequeue_get_subqueue_position($sqid, $nid)) {
    nodequeue_subqueue_remove($sqid, $pos);
  }
}

/**
 * Remove a node or node(s) from a nodequeue by position.
 *
 * If you know the nid but but not the position, use
 * @see nodequeue_subqueue_remove_node() instead.
 *
 * @param $sqid
 *   The subqueue to remove nodes from.
 * @param $start
 *   The first position (starting from 1) to remove.
 * @param $end
 *   The last position to remove. If NULL or equal to $start,
 *   only one node will be removed. Thus if $start is 1 and $end is 2,
 *   the first and second items will be removed from the queue.
 *
 */
function nodequeue_subqueue_remove($sqid, $start, $end = NULL) {
  if (!isset($end)) {
    $end = $start;
  }

  $diff = $end - $start + 1;
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position >= %d AND position <= %d", $sqid, $start, $end);
  db_query("UPDATE {nodequeue_nodes} SET position = position - %d WHERE sqid = %d AND position > %d",  $diff, $sqid, $end);
}

/**
 * Empty a subqueue.
 *
 * @param $sqid
 *   The sqid to empty.
 */
function nodequeue_queue_clear($sqid) {
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d", $sqid);
}

/**
 * Guarantee that a subqueue has not gotten too big. It's important to call
 * this after an operation that might have reduced a queue's maximum size.
 * It stores the count to save a query if this is to be followed by an add
 * operation.
 *
 * @param $queue
 *   The queue object.
 * @param $reference
 *   The subqueue to check.
 *
 */
function nodequeue_check_subqueue_size($queue, &$subqueue, $size = NULL) {
  if (!isset($size)) {
    $size = $queue->size;
  }

  if ($queue->size && $subqueue->count > $size) {
    nodequeue_subqueue_remove($subqueue->sqid, 1, $subqueue->count - $size);
    $subqueue->count = $size;
  }
}

/**
 * Guarantee that all subqueues are within the size constraints set
 * by $queue->size.
 */
function nodequeue_check_subqueue_sizes($queue) {
  // Don't check if size is 0, as that means infinite size.
  if (!$queue->size) {
    return;
  }

  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
  foreach ($subqueues as $subqueue) {
    nodequeue_check_subqueue_size($queue, $subqueue);
  }
}

/**
 * Swap two positions within a subqueue.
 */
function nodequeue_queue_swap($subqueue, $pos1, $pos2) {
  // Grab the nid off one of the positions so we can more easily swap.
  $nid = db_result(db_query("SELECT nid FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $pos1));
  if (!$nid) {
    return;
  }

  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE position = %d AND sqid = %d", $pos1, $pos2,  $subqueue->sqid);
  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE nid = %d AND sqid = %d", $pos2, $nid, $subqueue->sqid);
}

/**
 * Move a position within a subqueue up by one.
 */
function nodequeue_queue_up($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position - 1, $position);
}

/**
 * Move a position within a subqueue down by one.
 */
function nodequeue_queue_down($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position + 1, $position);
}

/**
 * Move an item to the front of the queue.
 */
function nodequeue_queue_front($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid= %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position + 1 WHERE sqid= %d AND position < %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (qid, sqid, nid, position, timestamp) VALUES (%d, %d, %d, 1, %d)", $entry->qid, $subqueue->sqid, $entry->nid, $entry->timestamp);
}

/**
 * Move an item to the back of the queue.
 */
function nodequeue_queue_back($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position - 1 WHERE sqid = %d AND position > %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (qid, sqid, nid, position, timestamp) VALUES (%d, %d, %d, %d, %d)", $entry->qid, $subqueue->sqid, $entry->nid, $subqueue->count, $entry->timestamp);
}

/**
 * Get the position of a node in a subqueue, or 0 if not found.
 */
function nodequeue_get_subqueue_position($sqid, $nid) {
  // We use MIN to make sure we always get the closes to the front of the
  // queue in case the queue has nodes in it multiple times.
  $pos = db_result(db_query("SELECT MIN(position) FROM {nodequeue_nodes} WHERE sqid = %d AND nid = %d", $sqid, $nid));
  return $pos;
}

/**
 * Get the position of a node in several subqueues.
 */
function nodequeue_set_subqueue_positions(&$subqueues, $nid) {
  $result = db_query("SELECT sqid, MIN(position) AS position FROM {nodequeue_nodes} WHERE sqid IN (%s) AND nid = %d GROUP BY sqid", implode(', ', array_keys($subqueues)), $nid);
  while ($obj = db_fetch_object($result)) {
    $subqueues[$obj->sqid]->position = $obj->position;
  }
}

/**
 * Get a list of valid subqueues for a node, along with the position of the node.
 *
 * @param $queues
 *   An array of fully loaded queue objects.
 * @param $node
 *   A fully loaded node object.
 *
 */
function nodequeue_get_subqueues_by_node($queues, $node) {
  // Determine which subqueues are valid for each queue.
  $references= array();
  foreach ($queues as $queue) {
    if ($result = nodequeue_api_subqueues($queue, $node)) {
      $references[$queue->qid] = is_array($result) ? $result : array($result);
    }
  }

  if (empty($references)) {
    return;
  }

  return nodequeue_load_subqueues_by_reference($references);
}

/**
 * Get a textual representation of a nodequeue's queue size.
 */
function nodequeue_subqueue_size_text($max, $count, $long = TRUE) {
  if (empty($count)) {
    $message = theme('nodequeue_subqueue_empty_text');
  }
  else if ($count == $max) {
    $message = theme('nodequeue_subqueue_full_text');
  }
  else {
    if ($long) {
      $message = theme('nodequeue_subqueue_count_text', $count);
    }
    else {
      $message = $count;
    }
  }
  return $message;
}

function theme_nodequeue_subqueue_empty_text() {
  return t('Queue empty');
}

function theme_nodequeue_subqueue_full_text() {
  return t('Queue full');
}

function theme_nodequeue_subqueue_count_text($count) {
  return t('@count in queue', array('@count' => $count));
}

/**
 * Substitute the subqueue title into some others tring.
 *
 * This function does NOT check_plain the title! The output MUST be checked
 * after this is complete.
 */
function nodequeue_title_substitute($text, $queue, $subqueue) {
  if (empty($text)) {
    return $subqueue->title;
  }
  $text = str_replace('%subqueue', $subqueue->title, $text);
  return $text;
}

/**
 * Shuffle a queue.
 *
 * @param $subqueue
 *   The subqueue to shuffle. May be a sqid or the loaded object.
 */
function nodequeue_subqueue_shuffle($subqueue) {
  // Load the queue
  if (!is_object($subqueue)) {
    $subqueue = nodequeue_load_subqueue($subqueue);
  }

  if (empty($subqueue)) {
    return;
  }

  $count = $subqueue->count;
  // Swap each item with another randomly picked one.
  foreach (range(1, $count) as $i) {
    nodequeue_queue_swap($subqueue, $i, rand(1, $count));
  }
}

/**
 * @} End of defgroup "nodequeue_api"
 */

// --------------------------------------------------------------------------
// Hooks to implement the default nodequeue type.

/**
 * Implementation of hook_nodequeue_info()
 */
function nodequeue_nodequeue_info() {
  return array('nodequeue' => array(
    'title' => t('Node queue'),
    'description' => t('Standard node queues have just one subqueue. Nodes put into a queue are added to the back of the queue; when a node is added to a full queue, the node in the front of the queue will be popped out to make room.'),
    ));
}

/**
 * Implementation of hook_nodequeue_form_submit()
 */
function nodequeue_nodequeue_form_submit(&$queue, $form) {
  // This will add a single subqueue to our new queue.
  if (!isset($queue->qid) && !isset($queue->add_subqueue)) {
    // A 0 will set the reference to the sqid of the queue.
    $queue->add_subqueue = array(0 => $queue->title);
  }
}

// --------------------------------------------------------------------------
// External queue fetching

/**
 * in general it's preferable to use Views for this functionality.
 */
function nodequeue_node_titles($sqid, $title = '', $backward = true, $from = 0, $count = 0) {
  $orderby = ($backward ? "DESC" : "ASC");
  $sql = db_rewrite_sql("SELECT n.nid, n.title FROM {node} n LEFT JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1 ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }
  return node_title_list($result, $title);
}

function nodequeue_nodes($sqid, $backward = true, $teaser = true, $links = true, $from = 0, $count = 0) {
  $orderby = ($backward ? "DESC" : "ASC");
  $sql = db_rewrite_sql("SELECT n.nid FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1 ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }

  while ($nid = db_fetch_object($result)) {
    $node = node_load($nid->nid);
    $output .= node_view($node, $teaser, false, $links);
  }
  return $output;
}

function nodequeue_fetch_front($sqid, $teaser = true, $links = true) {
  return nodequeue_nodes($sqid, false, $teaser, $links, 0, 1);
}

function nodequeue_fetch_back($sqid, $teaser = true, $links = true) {
  return nodequeue_nodes($sqid, true, $teaser, $links, 0, 1);
}

function nodequeue_fetch_random($sqid, $teaser = true, $links = true) {
  $count = db_result(db_query(db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1"), $sqid));
  return nodequeue_nodes($sqid, false, $teaser, $links, rand(0, $count - 1), 1);
}

/**
* Get the position of a node in a subqueue, or FALSE if not found.
*/
function nodequeue_subqueue_position($sqid, $nid) {
  return db_result(db_query("SELECT position FROM {nodequeue_nodes} WHERE sqid = %d AND nid = %d", $sqid, $nid));
}

/**
 * Get the position of a node in a queue; this queue MUST have only one
 * subqueue or the results of this function will be unpredictable.
 */
function nodequeue_queue_position($qid, $nid) {
  $sqid = db_result(db_query("SELECT sqid FROM {nodequeue_subqueue} WHERE qid = %d LIMIT 1", $qid));
  return nodequeue_subqueue_position($sqid, $nid);
}

// --------------------------------------------------------------------------
// API for modules implementing subqueues.

/**
 * Send the nodequeue edit form to the owning module for modification.
 *
 * @param $queue
 *   The queue being edited.
 * @param &$form
 *   The form. This may be modified.
 */
function nodequeue_api_queue_form($queue, &$form) {
  $function = $queue->owner . "_nodequeue_form";
  if (function_exists($function)) {
    $function($queue, $form);
  }
}

/**
 * Validate the nodequeue edit form.
 *
 * @param $queue
 *   The queue being edited.
 * @param $form_values
 *   The form values that were submitted.
 * @param &$form
 *   The actual form object. This may be modified.
 */
function nodequeue_api_queue_form_validate($queue, $form_values, &$form) {
  $function = $queue->owner . "_nodequeue_form_validate";
  if (function_exists($function)) {
    $function($queue, $form_values, $form);
  }
}

/**
 * Send the nodequeue edit form to the owning module upon submit.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_values
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit(&$queue, $form_values) {
  $function = $queue->owner . "_nodequeue_form_submit";
  if (function_exists($function)) {
    $function($queue, $form_values);
  }
}

/**
 * Send the nodequeue edit form to the owning module after the queue
 * has been saved.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_values
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit_finish($queue, $form_values) {
  $function = $queue->owner . "_nodequeue_form_submit_finish";
  if (function_exists($function)) {
    $function($queue, $form_values);
  }
}

/**
 * Fetch a list of subqueues that are valid for this node from
 * the owning module.
 *
 * @param $queue
 *   The queue being edited.
 * @param $node
 *   The loaded node object being checked.
 *
 * @return
 *   An array of subqueues. This will be keyed by $sqid.
 */
function nodequeue_api_subqueues(&$queue, $node) {
  $function = $queue->owner . "_nodequeue_subqueues";
  // This will return an array of references.
  if (function_exists($function)) {
    return $function($queue, $node);
  }
  else {
    return $queue->qid;
  }
}

/**
 * Fetch a list of nodes available to a given subqueue
 * for autocomplete.
 *
 * @param $queue
 *   The queue that owns the subqueue
 * @param $subqueue
 *   The subqueue
 * @param $string
 *   The string being matched.
 *
 * @return
 *   An keyed array $nid => $title
 */
function nodequeue_api_autocomplete($queue, $subqueue, $string) {
  $matches = array();
  if (empty($string)) {
    return $matches;
  }


  $where = "n.type IN (" . implode(', ', array_fill(0, count($queue->types), "'%s'")) . ')';
  $where_args = $queue->types;

  // Run a match to see if they're specifying by nid.
  $preg_matches = array();
  $match = preg_match('/\[nid: (\d+)\]/', $string, $preg_matches);
  if (!$match) {
    $match = preg_match('/^nid: (\d+)/', $string, $preg_matches);
  }

  if ($match) {
    // If it found a nid via specification, reduce our resultset to just that nid.
    $where .= " AND n.nid = %d";
    array_push($where_args, $preg_matches[1]);
  }
  else {
    // Build the constant parts of the query.
    $where .= " AND LOWER(n.title) LIKE LOWER('%s%%')";
    array_push($where_args, $string);
  }

  // Call to the API.
  $function = $queue->owner . "_nodequeue_autocomplete";
  if (function_exists($function)) {
    return $function($queue, $subqueue, $string, $where, $where_args);
  }
  else {
    $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title FROM {node} n WHERE $where"), $where_args, 0, 10);
    while ($node = db_fetch_object($result)) {
      $matches[$node->nid] = check_plain($node->title) . " [nid: $node->nid]";
    }
  }

  return $matches;
}

/**
 * Collect info about all of the possible nodequeue tyeps from owning
 * modules.
 */
function nodequeue_api_info() {
  return module_invoke_all('nodequeue_info');
}

/**
 * Allows the owning module of a queue to restrict access to viewing and
 * manipulating the queue.
 */
function nodequeue_api_queue_access($queue, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if ($queue->owner != 'nodequeue') { // Avoids an infinite loop.
    $function = $queue->owner . '_queue_access';
    if (function_exists($function)) {
      $access = $function($queue, $account);
    }
  }

  if (!isset($access)) {
    $access = TRUE;
  }
  return $access;
}

/**
 * Allows the owning module of a subqueue to restrict access to viewing and
 * manipulating the queue.
 */
function nodequeue_api_subqueue_access($subqueue, $account = NULL, $queue = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  
  if (!$queue) {
    $queue = nodequeue_load($subqueue->qid);
  }

  $function = $queue->owner . '_subqueue_access';
  if (function_exists($function)) {
    $access = $function($subqueue, $account, $queue);
  }

  if (!isset($access)) {
    $access = TRUE;
  }
  return $access;
}

/**
 * Form builder for the nodequeue settings tab.
 */
function nodequeue_admin_settings() {
  $form = array();
  $form['nodequeue_use_tab'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create a menu tab for each node that could belong to any queues'),
    '#default_value' => variable_get('nodequeue_use_tab', 1),
  );
  $form['nodequeue_tab_display_max'] = array(
    '#type' => 'checkbox',
    '#title' => t('Include a column on the nodequeue tab for the maximum number of nodes in each queue'),
    '#default_value' => variable_get('nodequeue_tab_display_max', 1),
  );
  $form['nodequeue_tab_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Node queue tab label'),
    '#default_value' => variable_get('nodequeue_tab_name', t('Node queue')),
    '#description' => t('If nodes will have a menu tab for manipulating related node queues, what should that tab be called?'),
  );
  return system_settings_form($form);
}

/**
 * Generate a query string to use on nodequeue's private links.
 *
 * @param $seed
 *   The seed to use when generating a token. If NULL no token will
 *   be generated.
 * @param $destination
 *   The destination to use. If FALSE one won't be used; if TRUE
 *   one will be generated from drupal_get_destination().
 * @param $query
 *   An array of additional items to add to the query.
 *
 * @return
 *   The query string suitable for use in the l() function.
 */
function nodequeue_get_query_string($seed, $destination = FALSE, $query = array()) {
  if ($dest = drupal_get_destination()) {
    $query[] = $dest;
  }

  if (isset($seed)) {
    $query[] = nodequeue_get_token($seed);
  }

  return implode('&', $query);
}

/**
 * Get a private token used to protect nodequeue's links from spoofing.
 */
function nodequeue_get_token($nid) {
  return 'token=' . drupal_get_token($nid);
}

/**
 * Check to see if the token generated from seed matches.
 */
function nodequeue_check_token($seed) {
  return drupal_get_token($seed) == $_GET['token'];
}

/**
 * Implementation of hook_simpletest().
 *
 */
function nodequeue_simpletest() {
  $dir = drupal_get_path('module', 'nodequeue') .'/tests';
  $tests = file_scan_directory($dir, '\.test$');
  return array_keys($tests);
}
